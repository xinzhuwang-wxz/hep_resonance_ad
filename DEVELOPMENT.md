# HEP Resonance Anomaly Detection - 开发文档

## 目录

1. [项目概述](#项目概述)
2. [Phase 1: 论文复现](#phase-1-论文复现)
3. [Phase 2: 方法扩展](#phase-2-方法扩展)
4. [Phase 3: 系统性诊断](#phase-3-系统性诊断)
5. [Phase 4: 通用化](#phase-4-通用化)
6. [技术规范](#技术规范)
7. [开发指南](#开发指南)
8. [验收标准总结](#验收标准总结)

---

## 项目概述

### 项目目标

构建一个**研究工程平台**，用于复现和扩展 CATHODE（dimuon anomaly detection）相关工作。平台应该：

1. **完全复现论文结果** - 同样的数据、同样的方法、同样的显著、能画同样图片，不浪费原代码的绘图函数
2. **代码结构清晰、模块化、可扩展** - 方便后续研究和扩展
3. **为后续研究预留接口** - 支持新方法、新特征、新分析
4. **可以量化常见痛点** - mass sculpting、假峰、鲁棒性等

可借鉴的仓库：

1. HEP 深度学习workflow相关内容和函数 ：
   - /Users/physicsboy/Documents/GitHub/bambooML

2. 代码设计风格思想请参考现代研究工程结构：
   - /Users/physicsboy/Documents/GitHub/Made-With-ML

### 核心设计原则

- ✅ **Research-first, not notebook-first** - 代码优先，notebook 仅用于探索
- ✅ **强配置驱动（YAML）** - 所有参数通过配置文件管理
- ✅ **物理逻辑与 ML 逻辑分离** - 清晰的模块划分
- ✅ **不硬编码路径、参数、超参数** - 全部可配置
- ✅ **每一张论文图都能通过一个脚本命令生成** - 一键复现
- ✅ **易于 debug、审查、扩展** - 清晰的日志、文档、接口

### 项目结构

```
hep_resonance_ad/
├── configs/              # 配置文件（YAML）
├── resonance_ad/         # 主代码包
│   ├── core/            # 核心功能（配置、日志、注册）
│   ├── data/            # 数据加载和处理
│   ├── physics/         # 物理相关函数
│   ├── models/          # ML 模型（Flow, Classifier等）
│   ├── analysis/        # 分析流程（bump hunt, significance等）
│   └── plotting/        # 画图模块
├── scripts/             # 可执行脚本
├── outputs/             # 输出目录（自动创建）
└── tests/               # 测试代码
```

---

## Phase 1: 论文复现

### 目标

**完全复现 CATHODE 论文中的分析结果**，包括：
- 同样的数据
- 同样的 sideband / signal region 划分
- 同样的 anomaly score
- 同样的显著性（~6σ）
- 同样的关键图（mass spectrum、score 分布等）

### 核心任务

#### 1.1 数据加载和预处理
- [x] 实现数据加载器（从 pickle 文件加载）
- [x] 实现事件筛选（至少 2 个 tight muon）
- [x] 实现 dimuon 运动学量计算
- [x] 实现数据预处理（logit transform, scaling）

**验收标准**：
- 能够从原始数据文件加载数据
- 数据格式与原始仓库一致
- 预处理后的数据可以直接用于训练

#### 1.2 Sideband 和 Signal Region 划分
- [x] 实现区域选择器（根据质量窗口划分）
- [x] 支持电荷筛选（OS/SS）
- [x] 实现派生特征计算（deltaR, deltaPT）

**验收标准**：
- 能够正确划分 SBL、SR、SBH
- 区域边界与论文一致
- 每个区域的事件数量合理

#### 1.3 CATHODE 模型实现
- [x] 实现 Normalizing Flow（MADE, BatchNorm, Reverse）
- [x] 实现 CATHODE 密度估计器
- [x] 实现训练循环
- [x] 实现模型保存和加载

**验收标准**：
- 模型架构与论文一致
- 训练损失能够收敛
- 模型能够生成样本
- 模型权重可以保存和加载

#### 1.4 背景拟合和 Bump Hunt
- [x] 实现背景拟合（多项式拟合）
- [x] 实现 anomaly score 计算
- [x] 实现 bump hunt 流程
- [x] 实现显著性计算

**验收标准**：
- 背景拟合的 chi-square 合理
- Anomaly score 分布符合预期
- 能够检测到预期的信号（如果有）
- 显著性计算正确

#### 1.5 论文图生成
- [x] 实现质量谱图
- [x] 实现 anomaly score 分布图
- [x] 实现显著性图
- [x] 实现 score vs mass 图
- [x] 实现背景拟合图

**验收标准**：
- 所有图都能通过脚本生成
- 图的格式和样式与论文一致
- 图的质量达到发表标准

### Phase 1 验收标准（总体）

✅ **功能完整性**：
- 所有核心功能都已实现
- 能够完整运行从数据加载到图生成的整个流程

✅ **结果一致性**：
- 使用相同数据能够复现论文结果
- 显著性在合理范围内（与论文结果一致）
- 关键图与论文一致

✅ **代码质量**：
- 代码结构清晰、模块化
- 有适当的注释和文档
- 遵循设计原则（配置驱动、无硬编码等）

✅ **可复现性**：
- 所有随机种子可设置
- 结果可复现
- 输出目录结构清晰

### Phase 1 交付物

1. **代码**：
   - 完整的数据加载和处理模块
   - CATHODE 模型实现
   - 训练和评估脚本
   - 画图模块

2. **文档**：
   - README.md
   - QUICKSTART.md
   - 脚本使用说明

3. **配置**：
   - 主配置文件（upsilon_reproduction.yaml）
   - 模型配置文件（CATHODE_8.yml）

4. **测试**：
   - 配置加载测试
   - 基本功能测试

---

## Phase 2: 方法扩展

### 目标

在 Phase 1 的基础上，**扩展支持其他异常检测方法**，包括：
- Simulation-free likelihood ratio learning（CWoLa / SALAD）
- Latent-space anomaly detection（LaCATHODE）
- Diffusion-based 方法（实验性）

### 核心任务

#### 2.1 Simulation-free Likelihood Ratio Learning

**2.1.1 CWoLa (Classification Without Labels)**
- [ ] 实现 CWoLa 分类器训练
- [ ] 实现 sideband 数据混合策略
- [ ] 实现分类器评估和 score 计算
- [ ] 集成到主流程中

**验收标准**：
- CWoLa 分类器能够训练
- Score 分布合理
- 能够与 CATHODE 结果对比

**2.1.2 SALAD (Simulation-Assisted Likelihood-free Anomaly Detection)**
- [ ] 实现 SALAD 方法
- [ ] 实现模拟数据生成
- [ ] 实现分类器训练
- [ ] 集成到主流程中

**验收标准**：
- SALAD 方法能够运行
- 结果与论文一致（如果有）
- 能够与 CATHODE 和 CWoLa 对比

#### 2.2 Latent-space Anomaly Detection

**2.2.1 LaCATHODE**
- [ ] 实现编码器（Encoder）
- [ ] 实现潜在空间密度估计
- [ ] 实现 anomaly score 计算
- [ ] 集成到主流程中

**验收标准**：
- 编码器能够训练
- 潜在空间表示合理
- Anomaly score 有效

**2.2.2 通用潜在空间方法接口**
- [ ] 定义统一的潜在空间方法接口
- [ ] 实现多种编码器架构（VAE, AE等）
- [ ] 实现潜在空间密度估计方法

**验收标准**：
- 接口清晰、易用
- 支持多种架构
- 能够与现有流程集成

#### 2.3 Diffusion-based 方法（实验性）

**2.3.1 Diffusion 模型实现**
- [ ] 实现 Diffusion 模型架构
- [ ] 实现训练循环
- [ ] 实现采样过程
- [ ] 实现 anomaly score 计算

**验收标准**：
- Diffusion 模型能够训练
- 能够生成样本
- Score 计算正确

**2.3.2 集成到分析流程**
- [ ] 将 Diffusion 方法集成到主流程
- [ ] 实现与其他方法的对比
- [ ] 标记为 EXPERIMENTAL

**验收标准**：
- 能够完成整个分析闭环
- 能够与其他方法比较
- 代码标记清楚（实验性）

### Phase 2 验收标准（总体）

✅ **方法实现**：
- 所有方法都已实现
- 方法接口统一、易用
- 代码结构清晰

✅ **结果对比**：
- 能够对比不同方法的结果
- 结果可视化清晰
- 性能指标可量化

✅ **可扩展性**：
- 新方法易于添加
- 接口设计合理
- 文档完整

### Phase 2 交付物

1. **代码**：
   - CWoLa 实现
   - SALAD 实现
   - LaCATHODE 实现
   - Diffusion 实现（实验性）
   - 方法对比脚本

2. **文档**：
   - 方法说明文档
   - API 文档
   - 对比结果报告

3. **配置**：
   - 各方法的配置文件
   - 对比实验配置

---

## Phase 3: 系统性诊断

### 目标

实现**系统性的诊断工具**，用于量化常见痛点和评估方法性能：
- Mass sculpting 风险
- 假峰（fake bump）风险
- 对无关特征（irrelevant features）的鲁棒性
- Look-elsewhere effect / global p-value
- 方法之间的稳定性比较

### 核心任务

#### 3.1 Mass Sculpting 诊断

**3.1.1 Mass Sculpting 指标**
- [ ] 实现 mass sculpting 检测方法
- [ ] 实现量化指标计算
- [ ] 实现可视化

**验收标准**：
- 能够检测 mass sculpting
- 指标量化合理
- 可视化清晰

**3.1.2 Mass Sculpting 测试**
- [ ] 实现 toy MC 测试
- [ ] 实现不同方法的对比
- [ ] 生成诊断报告

**验收标准**：
- 测试覆盖主要场景
- 结果可复现
- 报告清晰

#### 3.2 假峰（Fake Bump）诊断

**3.2.1 假峰检测**
- [ ] 实现假峰检测方法
- [ ] 实现假峰率计算
- [ ] 实现 toy MC 测试

**验收标准**：
- 能够检测假峰
- 假峰率计算正确
- 测试结果合理

**3.2.2 假峰可视化**
- [ ] 实现假峰可视化
- [ ] 实现假峰分布图
- [ ] 生成诊断报告

**验收标准**：
- 可视化清晰
- 报告完整

#### 3.3 无关特征鲁棒性测试

**3.3.1 特征重要性分析**
- [ ] 实现特征重要性计算
- [ ] 实现特征扰动测试
- [ ] 实现无关特征注入测试

**验收标准**：
- 能够识别重要特征
- 无关特征不影响结果
- 测试覆盖全面

**3.3.2 鲁棒性报告**
- [ ] 生成鲁棒性报告
- [ ] 可视化特征影响
- [ ] 提供改进建议

**验收标准**：
- 报告清晰
- 建议合理

#### 3.4 Look-elsewhere Effect / Global P-value

**3.4.1 Global P-value 计算**
- [ ] 实现 global p-value 计算
- [ ] 实现多种校正方法（Bonferroni, FDR等）
- [ ] 实现 toy MC 验证

**验收标准**：
- 计算正确
- 方法多样
- 验证充分

**3.4.2 Look-elsewhere Effect 可视化**
- [ ] 实现可视化
- [ ] 生成报告

**验收标准**：
- 可视化清晰
- 报告完整

#### 3.5 方法稳定性比较

**3.5.1 稳定性指标**
- [ ] 定义稳定性指标
- [ ] 实现指标计算
- [ ] 实现跨方法比较

**验收标准**：
- 指标合理
- 计算正确
- 比较公平

**3.5.2 稳定性报告**
- [ ] 生成稳定性报告
- [ ] 可视化对比结果
- [ ] 提供方法推荐

**验收标准**：
- 报告完整
- 推荐合理

### Phase 3 验收标准（总体）

✅ **诊断工具完整性**：
- 所有诊断工具都已实现
- 工具易用、文档完整

✅ **诊断结果可靠性**：
- 诊断结果合理
- 能够发现实际问题
- 建议可操作

✅ **可视化质量**：
- 可视化清晰
- 报告专业
- 易于理解

### Phase 3 交付物

1. **代码**：
   - 所有诊断工具
   - 测试脚本
   - 报告生成脚本

2. **文档**：
   - 诊断工具使用说明
   - 诊断结果解释指南
   - 最佳实践文档

3. **报告模板**：
   - 诊断报告模板
   - 可视化模板

---

## Phase 4: 通用化

### 目标

确保平台**通用化**，能够：
- 换 sample 只需改 YAML
- 支持批量实验
- 日志与状态清晰
- 可迁移到其他共振态分析

### 核心任务

#### 4.1 配置系统增强

**4.1.1 配置模板系统**
- [ ] 实现配置模板
- [ ] 实现配置验证
- [ ] 实现配置继承

**验收标准**：
- 配置模板完整
- 验证严格
- 继承清晰

**4.1.2 多样本支持**
- [ ] 实现多样本配置
- [ ] 实现批量处理
- [ ] 实现结果汇总

**验收标准**：
- 支持多样本
- 批量处理高效
- 汇总清晰

#### 4.2 批量实验支持

**4.2.1 实验管理**
- [ ] 实现实验注册系统
- [ ] 实现实验状态跟踪
- [ ] 实现实验对比

**验收标准**：
- 实验管理清晰
- 状态跟踪准确
- 对比方便

**4.2.2 结果管理**
- [ ] 实现结果存储
- [ ] 实现结果查询
- [ ] 实现结果对比

**验收标准**：
- 存储高效
- 查询方便
- 对比清晰

#### 4.3 日志和状态管理

**4.3.1 日志系统增强**
- [ ] 实现结构化日志
- [ ] 实现日志级别控制
- [ ] 实现日志分析工具

**验收标准**：
- 日志结构化
- 级别控制灵活
- 分析工具实用

**4.3.2 状态管理**
- [ ] 实现状态跟踪
- [ ] 实现状态恢复
- [ ] 实现状态可视化

**验收标准**：
- 状态跟踪准确
- 恢复可靠
- 可视化清晰

#### 4.4 可迁移性

**4.4.1 其他共振态支持**
- [ ] 实现通用共振态接口
- [ ] 实现 J/ψ, ψ(2S) 等支持
- [ ] 实现自定义共振态

**验收标准**：
- 接口通用
- 支持多种共振态
- 易于扩展

**4.4.2 数据格式适配**
- [ ] 实现多种数据格式支持
- [ ] 实现数据格式转换
- [ ] 实现数据验证

**验收标准**：
- 支持多种格式
- 转换可靠
- 验证严格

#### 4.5 性能优化

**4.5.1 计算优化**
- [ ] 实现并行处理
- [ ] 实现内存优化
- [ ] 实现 GPU 加速

**验收标准**：
- 并行高效
- 内存合理
- GPU 加速有效

**4.5.2 存储优化**
- [ ] 实现数据压缩
- [ ] 实现增量存储
- [ ] 实现缓存机制

**验收标准**：
- 压缩有效
- 增量存储可靠
- 缓存合理

### Phase 4 验收标准（总体）

✅ **通用性**：
- 能够处理多种样本
- 配置灵活
- 易于迁移

✅ **可扩展性**：
- 易于添加新功能
- 接口设计合理
- 文档完整

✅ **性能**：
- 计算高效
- 存储合理
- 用户体验好

### Phase 4 交付物

1. **代码**：
   - 增强的配置系统
   - 批量实验支持
   - 日志和状态管理
   - 通用化接口

2. **文档**：
   - 配置指南
   - 迁移指南
   - 性能优化指南
   - API 文档

3. **示例**：
   - 多样本配置示例
   - 批量实验示例
   - 迁移示例

---

## 技术规范

### 代码规范

1. **Python 风格**：
   - 遵循 PEP 8
   - 使用类型提示（Type Hints）
   - 文档字符串（Docstrings）

2. **模块设计**：
   - 单一职责原则
   - 接口清晰
   - 依赖最小化

3. **错误处理**：
   - 适当的异常处理
   - 清晰的错误信息
   - 日志记录

### 测试规范

1. **单元测试**：
   - 核心功能必须有测试
   - 测试覆盖率 > 80%
   - 测试独立、可复现

2. **集成测试**：
   - 端到端流程测试
   - 配置测试
   - 数据格式测试

### 文档规范

1. **代码文档**：
   - 所有公共函数有文档字符串
   - 复杂逻辑有注释
   - 类型提示完整

2. **用户文档**：
   - README 完整
   - 快速开始指南
   - API 文档

3. **开发文档**：
   - 设计决策记录
   - 开发指南
   - 贡献指南

### 版本控制

1. **Git 工作流**：
   - 主分支保护
   - 功能分支开发
   - 提交信息清晰

2. **版本号**：
   - 遵循语义化版本（Semantic Versioning）
   - 主版本号：重大变更
   - 次版本号：新功能
   - 修订号：bug 修复

---

## 开发指南

### 开发流程

1. **需求分析**：
   - 明确需求
   - 设计接口
   - 编写文档

2. **实现**：
   - 编写代码
   - 编写测试
   - 更新文档

3. **测试**：
   - 单元测试
   - 集成测试
   - 手动测试

4. **代码审查**：
   - 代码质量检查
   - 功能验证
   - 文档检查

5. **合并**：
   - 通过所有测试
   - 代码审查通过
   - 文档更新

### 添加新功能

1. **设计阶段**：
   - 明确功能需求
   - 设计接口
   - 考虑扩展性

2. **实现阶段**：
   - 创建新模块或扩展现有模块
   - 遵循代码规范
   - 编写测试

3. **集成阶段**：
   - 集成到主流程
   - 更新配置
   - 更新文档

4. **测试阶段**：
   - 功能测试
   - 性能测试
   - 用户测试

### 调试指南

1. **日志**：
   - 使用适当的日志级别
   - 记录关键信息
   - 结构化日志

2. **测试**：
   - 编写最小复现案例
   - 使用调试工具
   - 检查中间结果

3. **文档**：
   - 记录已知问题
   - 记录解决方案
   - 更新文档

---

## 验收标准总结

### Phase 1: 论文复现 ✅

- [x] 所有核心功能实现
- [x] 能够复现论文结果
- [x] 代码质量达标
- [x] 文档完整

### Phase 2: 方法扩展 🚧

- [ ] 所有方法实现
- [ ] 方法对比功能完整
- [ ] 接口统一、易用
- [ ] 文档完整

### Phase 3: 系统性诊断 🚧

- [ ] 所有诊断工具实现
- [ ] 诊断结果可靠
- [ ] 可视化质量高
- [ ] 报告专业

### Phase 4: 通用化 🚧

- [ ] 配置系统完善
- [ ] 批量实验支持
- [ ] 可迁移性强
- [ ] 性能优化

### 总体验收标准

✅ **功能完整性**：
- 所有 Phase 的功能都已实现
- 功能经过充分测试

✅ **代码质量**：
- 代码结构清晰
- 遵循设计原则
- 文档完整

✅ **可复现性**：
- 结果可复现
- 配置清晰
- 文档完整

✅ **可扩展性**：
- 易于添加新功能
- 接口设计合理
- 文档完整

---

## 时间线（建议）

- **Phase 1**: ✅ 已完成
- **Phase 2**: 预计 4-6 周
- **Phase 3**: 预计 3-4 周
- **Phase 4**: 预计 2-3 周

**总计**: 约 9-13 周

---

## 联系和贡献

如有问题或建议，请：
1. 提交 Issue
2. 提交 Pull Request
3. 联系维护者

---

**最后更新**: 2024年
**版本**: 1.0.0

